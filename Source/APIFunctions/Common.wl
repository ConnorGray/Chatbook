(*
	Initial content for this file is copied from the NeuralFunctions paclet
*)

BeginPackage["Wolfram`LLMTools`APIFunctions`Common`"]

Needs["GeneralUtilities`" -> "GU`"]

GU`SetUsage[DBPrint, "DBPrint[expr$] prints the expression expr$ if GU`$DebugMode is set to True."]

GU`SetUsage[DBEcho, "DBEcho[expr$] always return expr$ but also prints expr$ if GU`$DebugMode is set to True."]

GU`SetUsage[DBEchoHold, "DBEchoHold[expr$] evaluates and returns expr$, if\
 GU`$DebugMode is set to True it prints expr$ -> result$."]

GU`SetUsage[GetOption,"GetOption[name$] is a utility which can be used to access\
 option values of a caller function from the callee.

GetOption has to be locally redefined from the caller (within a Block or GU`Scope)\
 in the following way:
	GetOption = OptionValue[{CallerSymbol$, HiddenOptions$}, PassedOptions$, #]&;
where HiddenOptions$ (if present) is a list of additional options not exposed \
in Options[CallerSymbol$] and PassedOptions$ is the list of options passed from top level.

Otherwise, it is automatically available when using DefineFunction.

GetOption is an unevaluated symbol outside of the caller GU`Scope."]

GU`SetUsage[DefineFunction, "DefineFunction[symbol$, interface$, argnum$] is a\
 utility that adds a definition for symbol$.

It creates a downvalue for symbol$ which evaluates interface$[arguments$, options$] \
where arguments$ and options$ are parsed using

	System`Private`Arguments[symbol$[input], argnum$]

It supports the following options:
| \"ArgumentsPattern\" | Automatic | pattern for arguments of the top-level function |
| \"ExtraOptions\" | {} | a list of extra options not declared in Options[symbol$] |
| 'Parser' | Arguments | function to validate argument number and options |
| \"Wrapper\" | List |  a wrapper for the arguments$ and options$ sequence |
Option \"ArgumentsPattern\" defaults to ___. Can be set to a more restrictive pattern to \
enable unevaluated operator forms like Map[f].
Option 'Parser' can take the following values:
* System`Private`Arguments
* System`Private`ArgumentsWithRules

DefineFunction defines the utility GetOption as

	GetOption[name_] := OptionValue[{symbol$, extraOpts$}, options$, name]

and the variable

	$FunctionName = symbol$

that can be used anywhere in the dynamic GU`Scope of symbol$.

GU`ThrowFailure[tag$, args$] can be used inside the function GU`Scope \
and it is caught by GU`CatchFailureAsMessage using symbol$ as message head. When a failure \
occurs, the return value can either be the unevaluated call of $Failed, depending on the \
value of $AllowFailure (False by default).
"]

GU`SetUsage[DefineOperator,"DefineOperator[symbol$, interface$, argnum$] is a utility that adds a definition for symbol$.

It creates a downvalue for symbol$ of the form symbol$[args1__][arg2_] which evaluates to \
interface$[Join[{args2}, {args1}], options$] \
where arguments$ and options$ are parsed using

	System`Private`Arguments[symbol$[args1], argnum$]

It supports the following options:
| \"ArgumentsPattern\" | Automatic | pattern for arguments of the top-level function |
| \"SubArgumentsPattern\" | Automatic | pattern for arguments of subvalue |
| \"ExtraOptions\" | {} | a list of extra options not declared in Options[symbol$] |
| 'Parser' | Arguments | function to validate argument number and options |
| \"Wrapper\" | List |  a wrapper for the arguments$ and options$ sequence |
Option \"ArgumentsPattern\" defaults to ___.
Option \"SubArgumentsPattern\" defaults to _.
Option 'Parser' can take the following values:
* System`Private`Arguments
* System`Private`ArgumentsWithRules

DefineFunction defines the utility GetOption as

	GetOption[name_] := OptionValue[{symbol$, extraOpts$}, options$, name]

and the variable

	$FunctionName = symbol$

that can be used anywhere in the dynamic GU`Scope of symbol$.

GU`ThrowFailure[tag$, args$] can be used inside the function GU`Scope \
and it is caught by GU`CatchFailureAsMessage using symbol$ as message head. When a failure \
occurs, the return value can either be the unevaluated call of $Failed, depending on the \
value of $AllowFailure (False by default)."]

GU`SetUsage[$FunctionName, "$FunctionName is a variable that contains the name of a\
 function defined via DefineFunction."]

GU`SetUsage[$AllowFailure,"$AllowFailure can be set to True in the GU`Scope of any\
 top-level function (defined with DefineFunction) to return $Failed instead of\
 the unevaluated call when a GU`ThrowFailure is encountered. The unevaluated call\
 is usually returned when input argument validation fails, while $Failed is\
 returned when a runtime error occurs."]

GU`SetUsage[Cached, "Cached[expr$] evaluates expr$ and store the result in the\
 'Image' cache. Cached[expr$, key$] uses key$ to store the result of expr$.

If key$ is not provided, a new key will be generated by hashing expr$. \
Any part of expr$ wrapped in Evaluate will be evaluated before generating the key."]

GU`SetUsage[$Caching, "$Caching is a symbol that controls wether to use previously\
 stored results when using Cached"]

GU`SetUsage[$MockAPICalls, "$MockAPICalls can be used to switch from a real API call to a fake one \
when this path is implemented."]

Begin["`Private`"]

(* Row is needed to work around bug 415704 in the case of multi-arg Print *)
DBPrint[expr___] /; GU`$DebugMode := Print[Row[{expr}]]


DBEcho[expr_] /; GU`$DebugMode := (Print[expr]; expr)
DBEcho[expr_] := expr


SetAttributes[DBEchoHold, HoldAllComplete]
DBEchoHold[expr_] /; GU`$DebugMode := GU`EchoHold[expr]
DBEchoHold[expr_] := expr


Options[DefineFunction] = {
	"Wrapper" -> List,
	"ExtraOptions" -> {},
	"ArgumentsPattern" -> Automatic,
	"ArgumentsParser" -> System`Private`Arguments,
	"ExceptionHandler" -> GU`CatchFailureAsMessage
} // SortBy[ToString @* First];

DefineFunction[f_, interface_, argnum_, OptionsPattern[DefineFunction]] :=
With[
	{
		wrapper   = OptionValue["Wrapper"],
		extraOpts = OptionValue["ExtraOptions"],
		pattern = Replace[OptionValue["ArgumentsPattern"], Automatic -> ___],
		parser = Replace[OptionValue["ArgumentsParser"], 
			Except[System`Private`ArgumentsWithRules] -> System`Private`Arguments],
		handler = Replace[OptionValue["ExceptionHandler"],
			Except[GU`CatchFailure | GU`CatchFailureAndMessage | GU`CatchFailureAsMessage] -> GU`CatchFailureAsMessage
		]
	},

	f[input : pattern] := Block[
		{
			a, args, opts, result,
			$FunctionName, $AllowFailure,
			GetOption
		},
		
		a = parser[f[input], argnum, wrapper, extraOpts];

		(
			$AllowFailure = False;
			$FunctionName = f;
			{args, opts} = a;
			With[
				{passedOpts = opts},
				GetOption[name_] := OptionValue[{f, extraOpts}, passedOpts, name]
			];

			result = handler[f, interface[args, opts]];

			result /; !FailureQ[result] || $AllowFailure
		) /; Length[a] == 2
	];
]


Options[DefineOperator] = Join[
	Options[DefineFunction],
	{
		"SubArgumentsPattern" -> Automatic
	}
] // SortBy[ToString @* First];


DefineOperator[f_, interface_, argnum_, OptionsPattern[DefineOperator]] :=
With[
	{
		wrapper   = OptionValue["Wrapper"],
		extraOpts = OptionValue["ExtraOptions"],
		pattern = Replace[OptionValue["ArgumentsPattern"], Automatic -> ___],
		subPattern = Replace[OptionValue["SubArgumentsPattern"], Automatic -> _]
	},

	f[input : pattern][subInput : subPattern] := Block[
		{
			a, b, args, opts, result,
			$FunctionName, $AllowFailure,
			GetOption
		},

		a = System`Private`Arguments[f[input], argnum, wrapper, extraOpts];
		b = System`Private`Arguments[f[input][subInput], 1, wrapper];

		(
			$AllowFailure = False;
			$FunctionName = f;
			{args, opts} = a;
			With[
				{passedOpts = opts},
				GetOption[name_] := OptionValue[{f, extraOpts}, passedOpts, name]
			];

			(*
				one might argue that the order of args and subInput should be something
				that can be modified. the call could easily be
					result = GU`CatchFailureAsMessage[f, interface[args, subInput, opts]];
				but then separate interfaces for functions and operator forms need to be defined
			*)
			result = GU`CatchFailureAsMessage[f, interface[Join[First @ b, args], opts]];

			result /; !FailureQ[result] || $AllowFailure
		) /; Length[a] == 2 && Length[b] == 2
	];
]


(* Caching *)

SetAttributes[Cached, HoldFirst]

Cached[expr_] /; $Caching :=
GU`Scope[

	key = Hash@Replace[
		Hold[expr],
		Verbatim[Evaluate][x_] :> RuleCondition[x],
		Infinity
	];

	Cached[expr, key]
]

Cached[expr_, key_] /; $Caching :=
GU`Scope[
	res = Internal`CheckImageCache[key];

	If[
		FailureQ[res],
		res = Check[expr, $Failed];
		If[
			!FailureQ[res],
			Internal`SetImageCache[key, res]
		]
	];

	res

]

Cached[expr_, ___] := expr

End[] (* End `Private` *)

EndPackage[]